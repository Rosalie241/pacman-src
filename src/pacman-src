#!/usr/bin/env bash
#
# pacman-src - https://github.com/tim241/pacman-src
#
# Copyright (C) 2018 Tim Wanders <timwanders241@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Default 
_pkg_group=no
_pkg_file=none
_pkg_arch=none
_newline=yes
_search_only=no
_cached_found=no
_cache=no
_update=no
_build_only=no
if [ "x$_system_config_file" = "x" ]
then
    _system_config_file="/etc/pacman-src.conf"
fi
_init_cache_finished=no
# Check XDG_CACHE_HOME
# if empty, fall back to $HOME/.cache
if [ ! "$XDG_CACHE_HOME" ]
then
    XDG_CACHE_HOME="$HOME/.cache"
fi
# Check XDG_CONFIG_HOME 
# if empty, fall back to $HOME/.config
if [ ! "$XDG_CONFIG_HOME" ]
then
    XDG_CONFIG_HOME="$HOME/.config"
fi
# Check if the system config file exists
# else, error out
if [ -f "$_system_config_file" ]
then
    # shellcheck source=/etc/pacman-src.conf
    source "$_system_config_file"
else
    echo "missing required config: $_system_config_file!"
    exit 1
fi
# Source user configuration if available
if [ -f "$_user_config_file" ]
then
    # shellcheck disable=SC1090
    source "$_user_config_file"
fi
# Print text
#
function _print() {
    if [ "$_quiet" = "no" ]
    then
        if [ "$_newline" = "yes" ]
        then
            echo -e "\\n$*\\n"
        else
            echo -e "$*"
        fi
    fi
    return
}
# Print white text
function _wprint() {
    _print "${_color_green}=>>${_color_reset} ${_color_white}$* ${_color_reset}"
}
# Print red error text
function _errprint() {
    _print "${_color_red}=>> ERROR:${_color_reset} ${_color_white}$*${_color_reset}"
}
# Print yellow warning text
function _warnprint() {
    if [ "$_nowarn" = "no" ]
    then
        _print "${_color_yel}=>> WARNING:${_color_reset} ${_color_white}$*${_color_reset}"
    fi
}
# Print sub info
function _sprint() {
    _newline=no
    _print "  ${_color_blue}->${_color_white} $*${_color_reset}"
    _newline=yes
}
# Error out
#
function _err() {
    _errprint "$@"
    if [ "$_ignore_error" = "no" ]
    then
        exit 1
    fi
}
# clone the package repo to init the cache
#
function _init_cache() {
    _repo_dir_clone=no
    for _repo_dir in "${_repos[@]}"
    do
        if [ ! -d "$_target_dir/packages/$_repo_dir" ]
        then
            _repo_dir_clone=yes
        fi
    done
    if [ "$_repo_dir_clone" = "yes" ]
    then
        mkdir -p "$_target_dir"
        _wprint "Cloning packages repos"
        for _git_link in "${_repo_git_links[@]}"
        do
            _git_clone_dir="$(echo "$_git_link" | rev | cut -d'/' -f1 | rev | sed "s/.git//g")"
            git clone "$_git_link"  "${_git_flags[@]}" "$_target_dir/packages/$_git_clone_dir"
        done
        _update_symlinks 
    fi
}
# Update the cache
#
function _update_cache() {
    _wprint "Updating repos"
    for repo in "${_repos[@]}"
    do
        cd "$_target_dir/packages/$repo" || exit 1
        _sprint "updating ${_color_blue}$repo ${_color_white}repo"
        git fetch --all "${_git_flags[@]}" > /dev/null
        git reset --hard                   > /dev/null
    done
}
function _build_cd () {
    # note: '$repo' is from _start_search
    _found_dir=false
    for _arch in "${_repo_archs[@]}"
    do
        for _repo in "$@"
        do
            _target_build_dir="$_target_dir/packages/$repo/$_pkgname/repos/$_repo-$_arch"
            if [ -d "$_target_build_dir" ]
            then
                _found_dir=true
                _pkg_arch="$_arch"
                cd "$_target_build_dir" || exit 1
            fi
        done
    done
    if [ "$_found_dir" = "false" ]
    then
        _warnprint "${_color_blue}$_pkgname ${_color_white}not found in the ${_color_blue}$_repo_version ${_color_white}repos, building latest.."
        cd "$_target_dir/packages/$repo/$_pkgname/trunk" || exit 1
    fi
}
# Search the package
#
function _start_search() {
    _pkgname="$1"
    for repo in "${_repos[@]}"
    do
        _pkg_dir="$_target_dir/packages/$repo/$_pkgname"
        if [ -d "$_pkg_dir" ]
        then
            _pkg_not_found=no
            if [ "$_repo_testing" = "yes" ]
            then
                _repo_version="testing"
                _build_cd "${_testing_repos[@]}"
            else
                _repo_version="stable"
                _build_cd "${_stable_repos[@]}"
            fi
            return
        else
            _pkg_not_found=yes
        fi
    done
    if [ "$_pkg_not_found" = "yes" ]
    then
        for repo in "${_repos[@]}"
        do
            _repo_dir="$_target_dir/packages/$repo/"
            while read -r __package
            do
                _package_pkgbuild="$(echo "$__package" | cut -d':' -f1)"
                [ -f "$_package_pkgbuild" ] && source "$_package_pkgbuild" 2> /dev/null
                for _package_name in "${pkgname[@]}" "${provides[@]}" "${pkgbase[@]}"
                do
                    if [ -d "$_repo_dir/$_package_name" ]
                    then
                        _pkgname="$_package_name"
                        if [ "$_repo_testing" = "yes" ]
                        then
                            _repo_version="testing"
                            _build_cd "${_testing_repos[@]}"
                        else
                            _repo_version="stable"
                            _build_cd "${_stable_repos[@]}"
                        fi
                        return
                    fi
                done
            done < <(grep -EH "pkgname=.*$_pkgname" "$_repo_dir"/*/repos/*/PKGBUILD)
        done
        if _group_packages="$(pacman -Qqg "$1" 2>/dev/null)"
        then
            if [ "$_search_pkg_only" = "no" ]
            then
                _pkg_group=yes
                for _package in $_group_packages
                do
                    _packages_group+=("$_package")
                done
            fi
        else
            _err "${_color_blue}$1${_color_white} not found!"
        fi
    fi
}
# Start the build using makepkg
#
function _start_build() {
    if [ "$_cached_found" = "yes" ]
    then
        _cached_found=no
        return
    fi
    _wprint "Building ${_color_blue}$1"
    if [ "$_build_only" = "yes" ] || \
        [ "$_cache" = "yes" ]
    then
        if [ ! -d "$_target_cache_dir" ]
        then
            mkdir -p "$_target_cache_dir"
        fi
        export PKGDEST="$_target_cache_dir"
    fi
    if makepkg "${_makepkg_flags[@]}"
    then        
        if [ "$_build_only" = "no" ]
        then
            _wprint "Installing ${_color_blue}$1"
            if ! sudo pacman "${_pacman_flags[@]}" -U "$_pkg_file"
            then
                _err "Installing ${_color_blue}$1 ${_color_white}failed!"
            fi
        fi
        if [ "$_clean" = "yes" ]
        then
            _wprint "Cleaning ${_color_blue}$1"
            git clean -fdxq
        fi
        return
    else
        _err "Building ${_color_blue}$1 ${_color_white}failed!"
    fi
}
# Checks requirements
#
function _checkreq() {
    # Make sure we're not running as root!
    if [ "$UID" = "0" ]
    then
        _errprint "running this program as root is NOT allowed!"
        exit 1
    fi
    _missing_req=no
    for _cmd in git pacman bash makepkg ln sudo
    do
        if ! command -v $_cmd > /dev/null 2>/dev/null
        then
            _errprint "Missing requirement: ${_color_blue}$_cmd"
            _missing_req=yes
        fi
    done
    if [ "$_missing_req" = "yes" ]
    then
        exit 1
    fi
    if [ -f "/etc/os-release" ]
    then
        ID=NULL
        export "$(grep ID /etc/os-release | head -1)" 2>/dev/null
        if [ "$ID" != "arch" ]
        then
            if [ "$_distro_warning" = "yes" ]
            then
                _warnprint "Unsupported platform detected, continue at your own risk"
            fi
        fi
        unset ID
    fi
    if [ ! -f "/etc/makepkg.conf" ]
    then
        _err "makepkg.conf not found!"
    else
        # shellcheck disable=SC1091
        source "/etc/makepkg.conf"
        if [ ! "$PKGEXT" ]
        then
            _err "PKGEXT is empty!"
        fi
    fi
}
# Get Package filename
function _pkg_info_file() {
    # '$_pkg_arch' from _build_cd
    if _pkg_file="$(makepkg --packagelist | grep "$1" \
                | grep "$_pkg_arch" \
                | head -1)$PKGEXT"
    then
        for _arch in "${_repo_archs[@]}"
        do
            _pkg_file="$(makepkg --packagelist | grep "$1" \
                        | grep "$_arch" \
                        | head -1)$PKGEXT"
            if [ "$_pkg_file" != "$PKGEXT" ]
            then
                return
            fi
        done
        # Extra sanity check
        if [ "$_pkg_file" = "$PKGEXT" ]
        then
            _warnprint "cannot find architecture for ${_color_blue}$1"
            _pkg_file="$(makepkg --packagelist | grep "$1" | head -1)$PKGEXT"
            if [ "$_pkg_file" = "$PKGEXT" ]
            then
                _err "failed to retrieve the filename for ${_color_blue}$1"
            else
                return
            fi
        fi

    else
        _err "failed to retrieve the filename for ${_color_blue}$1"
    fi
}
# Get package info
#
function _pkg_info() {
    # '$_pkg_dir  ' from _start_search
    if _real_pkg_dir=$(readlink "$_pkg_dir")
    then
        if [ "x$_real_pkg_dir" = "x$_old_pkg_dir" ]
        then
            return
        fi  
    else
        if [ "x$_pkg_dir" = "x$_old_pkg_dir" ]
        then
            return
        fi
    fi
    _old_pkg_dir="$_pkg_dir"  
    # shellcheck disable=SC1091
    source ./PKGBUILD 2> /dev/null
    # Check if PKGBUILD has been patched already
    # shellcheck disable=SC2016
    if [[ "$pkgver" != *"_src" ]]
    then
        _wprint "Patching PKGBUILD for ${_color_blue}$1"
        # Example code for this pkgver change
        # Example pkgver=1.0
        #
        # source=('example.com/files/$pkgname-$pkgver')
        # =
        # source=('example.com/files/${pkgname}-1.0')
        sed -i s/'$pkgver'/"$pkgver"/g          PKGBUILD
        # source=('example.com/files/${pkgname}_${pkgver}')
        # =
        # source=('example.com/files/${pkgname}_1.0')
        sed -i s/'${pkgver}'/"$pkgver"/g        PKGBUILD
        # source=('example.com/files/${pkgname}_${pkgver//./_}')
        # =
        # source=('example.com/files/${pkgname}_${origpkgver//./_}')
        sed -i s/'${pkgver'/'${origpkgver'/g    PKGBUILD
        #
        # pkgver=1.0
        # =
        # pkgver=1.0_src \n origpkgver=1.0
        _sprint "changing pkgver to ${_color_blue}${pkgver}_src"
        _pkgbuild_data="$(cat PKGBUILD)"
        _in_func=no
        _echo=yes
        while read -r line 
        do
            # if the line contains pkgver= then replace and add
            # pkgver=[VERSION]_src
            # origpkgver=[VERSION]
            [[ "$line" = "pkgver="* ]] && echo -e "pkgver=${pkgver}_src\\norigpkgver=$pkgver" && _echo=no
            # 
            # If _in_func_next = yes then set _in_func to yes
            [ "$_in_func_next" = "yes" ] && _in_func=yes
            #
            # If the line contains '{' add \t at the next line
            [[ "$line" = *"{" ]] && _in_func_next=yes && _in_func=no
            #
            # If the line contains '}' do not add \t to the line 
            [[ "$line" = "}"* ]] && _in_func=no && _echo=yes
            #
            # if it's in the function, add \t before the text
            [ "$_in_func" = "yes" ] && echo -e "\\t$line" && _echo=no
            #
            # If _echo = yes then show the original line without additions
            [ "$_echo" = "yes" ] && echo "$line" || _echo=yes
        done < <(echo "$_pkgbuild_data") > PKGBUILD
        # Example pkgver function
        #
        # pkgver() {
        #   echo 1.1
        # } 
        # =
        # pkgver() {
        #   echo '1.0_src'
        #   return
        #   echo 1.1
        # }
        #
        # Grep the pkgver function
        _line="$(grep "pkgver*.*() {" PKGBUILD -n | cut -d':' -f1 2> /dev/null)"
        # Check if grep found something
        if _line="$(grep "pkgver*.*() {" PKGBUILD -n | cut -d':' -f1)" && \
            [ "x$_line" != "x" ]
        then
            _sprint "changing pkgver function to dummy function"
            _rline=$((_line + 1)) 2> /dev/null
            sed -i "${_rline}s^.*^echo \\'${pkgver}_src\\'\\nreturn;^g" PKGBUILD
        fi
        _sprint "generating SRCINFO"
        makepkg --printsrcinfo > .SRCINFO
        pkgver="${pkgver}_src"
    fi
}
# Checks if package has been built already 
#
function _check_cache() {
    if [ -f "$_target_cache_dir/$_pkg_file" ]
    then
        _cached_found=yes
        if [ "$(pacman -Qi "$1" | grep Version | cut -d':' -f2 | cut -d'-' -f1 | sed "s/ //g")" = "$pkgver" ]
        then
            _wprint "Package ${_color_blue}$1-$pkgver ${_color_white}has already been installed!"
            return
        fi
        _wprint "Package ${_color_blue}$1 ${_color_white}has been built already, installing cached version!"
        if ! sudo pacman "${_pacman_flags[@]}" -U "$_target_cache_dir/$_pkg_file"
        then
            _err "Failed to install ${_color_blue}$1"
        fi
    fi
}
# Displays usage
#
function _usage() {
    if [ "$_quiet" = "no" ]
    then
        echo -e "pacman-src compiles Arch GNU/Linux packages from source using the ABS\\n"
        echo "Usage: pacman-src [OPTION] [PACKAGE]"
        echo -e "\\nOptions:"
        echo "  -u, --update        updates the cache"
        echo "  -b. --build         build-only, no installing"
        echo "  -m, --cache         use the cache to store the built packages"
        echo "  -f, --force         passes --force to pacman and makepkg"
        echo "  -s, --skipchecks    skips any integrity check(s)"
        echo "  -n, --noconfirm     passes --noconfirm to pacman and makepkg"
        echo "  -t, --testing       builds the latest version of the given package(s)"
        echo "  -q, --quiet         silent mode"
        echo "  -Q, --search        searches the given package(s), returns 0 when found"
        echo "  --reset             resets git repos from the cache"
        echo "  --config=[FILE]     uses configuration options from given config file"
        echo "  -l, --nocheck       skips do_check function for given package(s)"
        echo "  -c, --cleanbuild    cleans build before building package"
        echo "  -d, --dirty         does not clean, even when build was successful"
        echo "  -g, --ignore        does not exit after error"
        echo "  -x, --nowarn        disables warning(s)"
        echo "  -h, --help          displays this help and exit"
        echo "  -v, --version       displays version and exit"
        echo -e "\\nExamples:"
        echo "  pacman-src base     (re)compiles all packages from base group"
        echo -e "  pacman-src bash -n  compiles and installs bash package without confirmation\\n"
        echo "Report bugs to https://github.com/tim241/pacman-src"
    fi
}
# Displays version
#
function _version() {
    echo -e "pacman-src @VERSION@\\n"
    echo "Copyright (C) 2018 Tim Wanders"
    echo -e "This is free software; see the source for copying conditions.\\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n"
    echo "Written by Tim Wanders."
}
# Main build loop
#
function _build_loop() {
    if [ "$_search_only" = "yes" ] || \
        [ "${#@}" = "0" ]
    then
        return
    fi
    for _package in "$@"
    do
        _start_search "$_package"
        if [ "$_pkg_group" = "no" ]
        then
            _pkg_info      "$_package"
            _pkg_info_file "$_package"
            if [ "$_cache" = "yes" ]
            then
                _check_cache "$_package"
            fi
            _start_build "$_package"
        else
            _pkg_group=no
        fi
    done
}
# Sources given config file
#
function _use_config() {
    _config="$(echo "$1" | cut -d'=' -f2)"
    if [ -f "$_config" ] &&
       [ "x$_config" != "x" ]
    then
        # shellcheck disable=SC1090
        source "$_config"
    else
        _usage
    fi    
}
# Resets repos
#
function _reset() {
    _wprint "Resetting repos"
    for repo in "${_repos[@]}"
    do
        if [ -d "$_target_dir/packages/$repo" ]
        then
            cd "$_target_dir/packages/$repo" || return
            _sprint "resetting ${_color_blue}$repo"
            git reset --hard > /dev/null 2>&1
        fi
    done
}
# Short argument parser
#
function _parse_short() {
    args=$(echo "$@" | sed "s/-//g" | grep -o .)
    for arg in $args
    do
        case $arg in
                b) _build_only=yes;;
                q) _quiet=yes;;
                Q) _search_only=yes;;
                u) _update=yes;;
                s) _makepkg_flags+=(--skipinteg);;
                n) _makepkg_flags+=(--noconfirm); _pacman_flags+=(--noconfirm);;
                c) _makepkg_flags+=(--cleanbuild);;
                t) _repo_testing=yes;;
                d) _clean=no;;
                f) _makepkg_flags+=(-f); _pacman_flags+=(--force);;
                l) _makepkg_flags+=(--nocheck);;
                m) _cache=yes;;
                g) _ignore_error=yes;;
                x) _nowarn=yes;;
                h) _usage; exit;;
                v) _version; exit;;
                *) _usage; exit 1;;
        esac
    done
}
if [ "${#@}" = "0" ]
then
    _usage
    exit
fi
for _argument in "$@"
do
    case $_argument in
        --build)        _build_only=yes;;
        --quiet)        _quiet=yes;;
        --search)       _search_only=yes;;
        --update)       _update=yes;;
        --skipchecks)   _makepkg_flags+=(--skipinteg);;
        --noconfirm)    _makepkg_flags+=(--noconfirm); _pacman_flags+=(--noconfirm);;
        --cleanbuild)   _makepkg_flags+=(--cleanbuild);;
        --nocheck)      _makepkg_flags+=(--nocheck);;
        --testing)      _repo_testing=yes;;
        --dirty)        _clean=no;;
        --reset)        _reset;;
        --force )       _makepkg_flags+=(-f); _pacman_flags+=(--force);;
        --cache)        _cache=yes;;
        --ignore)       _ignore_error=yes;;
        --nowarn)       _nowarn=yes;;
        --config=*)     _use_config "$_argument";;
        --help)         _usage; exit;;
        --version)      _version; exit;;
        --*)            _usage; exit 1;;
        -*)             _parse_short "$_argument" ;;
        *)              _packages+=("$_argument");;
    esac
done
_checkreq
_init_cache
[ "$_update" = "yes" ] && _update_cache
# Search all packages before building
if [ "${_packages[0]}" ]
then  
    _wprint "Searching packages"
fi
_search_pkg_only=yes
for _package in "${_packages[@]}"
do
    _nowarn=yes
    _sprint "searching ${_color_blue}$_package"
    _start_search "$_package"
    _nowarn=no
done
# Remove duplicates
if [ "${_packages[1]}" ]
then  
    _wprint "Searching for duplicate packages"
fi
for _package in "${_packages[@]}"
do
    for _dpackage in "${_dpackages[@]}"
    do
        if [ "$_dpackage" = "$_package" ]
        then
            _sprint "duplicate found: ${_color_blue}$_package"
            _duplicate=yes
        fi
    done
    if [ "$_duplicate" != "yes" ]
    then
        _stripped_packages+=("$_package")
        _dpackages+=("$_package")
    fi
done
_search_pkg_only=no
# Start searching and building
_build_loop "${_stripped_packages[@]}"
_build_loop "${_packages_group[@]}"

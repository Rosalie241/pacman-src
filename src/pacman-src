#!/usr/bin/env bash
#
# pacman-src - https://github.com/tim241/pacman-src
#
# Copyright (C) 2018 Tim Wanders <timwanders241@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Default 
_verbose=no
_pkg_group=no
_pkg_file=none
_pkg_arch=none
_newline=yes
_search_only=no
_cached_found=no
_cache=no
_update=no
_build_only=no
_ignore_installed=no
_trunk=no
_noconfirm=no
_package_total=0
_package_num=1
if [ "x$_system_config_file" = "x" ]
then
    _system_config_file="/etc/pacman-src.conf"
fi
# Check XDG_CACHE_HOME
# if empty, fall back to $HOME/.cache
if [ ! "$XDG_CACHE_HOME" ]
then
    XDG_CACHE_HOME="$HOME/.cache"
fi
# Check XDG_CONFIG_HOME 
# if empty, fall back to $HOME/.config
if [ ! "$XDG_CONFIG_HOME" ]
then
    XDG_CONFIG_HOME="$HOME/.config"
fi
# Check if the system config file exists
# else, error out
if [ -f "$_system_config_file" ]
then
    # shellcheck source=/etc/pacman-src.conf
    source "$_system_config_file"
else
    echo "missing required config: $_system_config_file!"
    exit 1
fi
# Source user configuration if available
if [ -f "$_user_config_file" ]
then
    # shellcheck disable=SC1090
    source "$_user_config_file"
fi
# Print text
#
function _print() {
    if [ "$_quiet" = "no" ]
    then
        if [ "$_newline" = "yes" ]
        then
            echo -e "\\n$*\\n"
        else
            echo -e "$*"
        fi
    fi
}
# Print white text
function _wprint() {
    _print "${_color_green}=>>${_color_reset} ${_color_white}$* ${_color_reset}"
}
# Print red error text
function _errprint() {
    _print "${_color_red}=>> ERROR:${_color_reset} ${_color_white}$*${_color_reset}" >&2
}
# Print yellow warning text
function _warnprint() {
    if [ "$_nowarn" = "no" ]
    then
        _print "${_color_yel}=>> WARNING:${_color_reset} ${_color_white}$*${_color_reset}"
    fi
}
# Print log info
function _log() {
    if [ "$_verbose" = "yes" ]
    then
        _newline=no
        _print "${_color_white}[DEBUG] $*${_color_reset}"
        _newline=yes
    fi
}
# Print sub info
function _sprint() {
    _newline=no
    _print "  ${_color_blue}->${_color_white} $*${_color_reset}"
    _newline=yes
}
# Error out
#
function _err() {
    _errprint "$@"
    if [ "$_ignore_error" = "no" ]
    then
        exit 1
    fi
}
# clone the package repo to init the cache
#
function _init_cache() {
    _repo_dir_clone=no
    _log "checking if all repos exist"
    for _repo_dir in "${_repos[@]}"
    do
        _target_repo_dir="$_target_dir/packages/$_repo_dir"
        _log "checking if '$_target_repo_dir' exists"
        if [ ! -d "$_target_dir/packages/$_repo_dir" ]
        then
            _log "'$_target_repo_dir' not found"
            _repo_dir_clone=yes
        fi
    done
    if [ "$_repo_dir_clone" = "yes" ]
    then
        mkdir -p "$_target_dir"
        _wprint "Cloning packages repos"
        for _git_link in "${_repo_git_links[@]}"
        do
            _git_clone_dir="$(echo "$_git_link" | rev | cut -d'/' -f1 | rev | sed "s/.git//g")"
            if [ ! -d "$_target_dir/packages/$_git_clone_dir" ]
            then
                _log "Cloning '$_git_link' to '$_target_dir/packages/$_git_clone_dir'"
                git clone "$_git_link"  "${_git_flags[@]}" "$_target_dir/packages/$_git_clone_dir"
            fi
        done 
    fi
}
# Update the cache
#
function _update_cache() {
    _wprint "Updating repos"
    for repo in "${_repos[@]}"
    do
        cd "$_target_dir/packages/$repo" || exit 1
        _sprint "updating ${_color_blue}$repo ${_color_white}repo"
        git fetch --all "${_git_flags[@]}" > /dev/null
        git reset --hard                   > /dev/null
    done
}
function _build_cd () {
    # note: '$repo' is from _start_search
    _found_dir=false
    if [ "$_trunk" = "yes" ]
    then
        _trunk_dir="$_target_dir/packages/$repo/$_pkgname/trunk"
        _log "_trunk enabled, checking if '$_trunk_dir' exists"
        if [ -d "$_trunk_dir" ]
        then
            _log "'$_trunk_dir' exists"
            # shellcheck disable=SC2164
            cd "$_trunk_dir"
            return
        else
            _log "'$_trunk_dir' does not exist"
            _err "trunk does not exist for '$_pkgname'!"
        fi
    fi
    for _arch in "${_repo_archs[@]}"
    do
        for _repo in "$@"
        do
            _target_build_dir="$_target_dir/packages/$repo/$_pkgname/repos/$_repo-$_arch"
            _log "checking if '$_target_build_dir' exists"
            if [ -d "$_target_build_dir" ]
            then
                _log "'$_target_build_dir' exists"
                _found_dir=true
                _pkg_arch="$_arch"
                cd "$_target_build_dir" || exit 1
                break
            else
                _log "'$_target_build_dir' does not exist"
            fi
        done
    done
    if [ "$_found_dir" = "false" ]
    then
        _log "package not found in any repos, defaulting to trunk"
        _warnprint "${_color_blue}$_pkgname ${_color_white}not found in the ${_color_blue}$_repo_version ${_color_white}repos, building latest.."
        _trunk_dir="$_target_dir/packages/$repo/$_pkgname/trunk"
        if [ -d "$_trunk_dir" ]
        then
            # shellcheck disable=SC2164
            cd "$_trunk_dir"
            return
        else
            _err "trunk does not exist for '$_pkgname'!"
        fi
    fi
}
# Search the package
#
function _start_search() {
    _pkgname="$1"
    _pkgname_pacman_src_real="$_pkgname"
    for repo in "${_repos[@]}"
    do
        _pkg_dir="$_target_dir/packages/$repo/$_pkgname"
        _log "checking if '$_pkg_dir' exists"
        if [ -d "$_pkg_dir" ]
        then
            _log "'$_pkg_dir' found"
            _pkg_not_found=no
            _log "checking what repos are enabled"
            if [ "$_repo_testing" = "yes" ]
            then
                _log "testing repos are enabled"
                _repo_version="testing"
                _build_cd "${_testing_repos[@]}"
            else
                _log "stable repos are enabled"
                _repo_version="stable"
                _build_cd "${_stable_repos[@]}"
            fi
            return
        else
            _pkg_not_found=yes
        fi
    done
    if [ "$_pkg_not_found" = "yes" ]
    then
        _log "package not found, searching in a different way"
        for repo in "${_repos[@]}"
        do
            _log "searching package in the '$repo' repo using grep"
            _repo_dir="$_target_dir/packages/$repo/"
            while read -r __package
            do
                _package_pkgbuild="$(echo "$__package" | cut -d':' -f1)"
                _package_pkgname_found=no
                _log "checking if '$_package_pkgbuild' exists"
                if [ -f "$_package_pkgbuild" ] 
                then
                    _log "'$_package_pkgbuild' found"
                    # shellcheck disable=SC2164
                    cd "$(dirname "$_package_pkgbuild")"
                    _log "sourcing '$_package_pkgbuild'"
                    # shellcheck disable=SC1090
                    source "$_package_pkgbuild" 2> /dev/null
                fi
                # Override _pkgname if defined in PKGBUILD
                _pkgname="$_pkgname_pacman_src_real"
                _log "checking if pkgname, provides or pkgbase array contain package"
                # shellcheck disable=SC2154
                for _package_name in "${pkgname[@]}" "${provides[@]}" "${pkgbase[@]}"
                do
                    _log "checking if '$_package_name' is '$_pkgname'"
                    if [ "$_package_name" = "$_pkgname" ] 
                    then 
                        _log "'$_package_name' is '$_pkgname'"
                        _package_pkgname_found=yes 
                        break
                    else
                        _log "'$_package_name' is not '$_pkgname'"
                    fi
                done
                # shellcheck disable=SC2154
                for _package_name in "${pkgname[@]}" "${provides[@]}" "${pkgbase[@]}"
                do
                    [ "$_package_pkgname_found" = "no" ] && break

                    _log "checking if '$_repo_dir/$_package_name' exists"
                    if [ -d "$_repo_dir/$_package_name" ]
                    then
                        _log "'$_repo_dir/$_package_name' exists"
                        _pkgname="$_package_name"
                        _log "checking what repos are enabled"
                        if [ "$_repo_testing" = "yes" ]
                        then
                            _log "testing repos are enabled"
                            _repo_version="testing"
                            _build_cd "${_testing_repos[@]}"
                        else
                            _log "stable repos are enabled"
                            _repo_version="stable"
                            _build_cd "${_stable_repos[@]}"
                        fi
                        return
                    fi
                done
            done < <(LC_ALL=C; \
                grep -EH "pkgname=.*$_pkgname.*" "$_repo_dir"/*/repos/*/PKGBUILD || \
                grep -EH "pkgbase=.*$(echo "$_pkgname" | cut -d'-' -f1).*" "$_repo_dir"/*/repos/*/PKGBUILD)
        done
        if _group_packages="$(pacman -Qqg "$1" 2>/dev/null)"
        then
            if [ "$_search_pkg_only" = "no" ]
            then
                _pkg_group=yes
                ((_package_total--))
                for _package in $_group_packages
                do
                    _packages_group+=("$_package")
                    ((_package_total++))
                done
            fi
        else
            _err "${_color_blue}$1${_color_white} not found!"
        fi
    fi
}
# Cleans the package
#
function _pkg_clean() {
    _wprint "Cleaning ${_color_blue}$1"
    git clean -fdxq
}
# Start the build using makepkg
#
function _start_build() {
    if [ "$_cached_found" = "yes" ]
    then
        _cached_found=no
        return
    fi
    if [ "$_build_only" = "yes" ] || \
        [ "$_cache" = "yes" ]
    then
        if [ ! -d "$_target_cache_dir" ]
        then
            mkdir -p "$_target_cache_dir"
        fi
        export PKGDEST="$_target_cache_dir"
        _pkg_file="$_target_cache_dir/$_pkg_file"
    fi
    [ "$_cleanbuild" = "yes" ] && _pkg_clean "$1"
    if makepkg "${_makepkg_flags[@]}"
    then        
        if [ "$_build_only" = "no" ]
        then
            _wprint "Installing ${_color_blue}$1"
            if ! sudo pacman "${_pacman_flags[@]}" -U "$_pkg_file"
            then
                _err "Installing ${_color_blue}$1 ${_color_white}failed!"
            fi
        fi
        [ "$_clean" = "yes" ] && _pkg_clean "$1"
        return
    else
        _err "Building ${_color_blue}$1 ${_color_white}failed!"
    fi
}
# Checks requirements
#
function _checkreq() {
    # Make sure we're not running as root!
    if [ "$UID" = "0" ]
    then
        _errprint "running this program as root is NOT allowed!"
        exit 1
    fi
    _missing_req=no
    for _cmd in git pacman bash makepkg ln sudo
    do
        if ! command -v $_cmd > /dev/null 2>/dev/null
        then
            _errprint "Missing requirement: ${_color_blue}$_cmd"
            _missing_req=yes
        fi
    done
    if [ "$_missing_req" = "yes" ]
    then
        exit 1
    fi
    if [ -f "/etc/os-release" ]
    then
        ID=NULL
        export "$(grep ID /etc/os-release | head -1)" 2>/dev/null
        if [ "$ID" != "arch" ] || \
            [ "$ID" = "NULL" ]
        then
            if [ "$_distro_warning" = "yes" ]
            then
                _warnprint "Unsupported platform detected, continue at your own risk"
            fi
        fi
        unset ID
    fi
}
# Get Package filename
function _pkg_info_file() {
    # '$_pkg_arch' from _build_cd
    _log "searching filename of package"
    if _pkg_file="$(makepkg --packagelist | grep "$1" \
                | grep "$_pkg_arch" \
                | head -1)"
    then
        for _arch in "${_repo_archs[@]}"
        do
            _log "searching '$1' filename for architecture '$_arch'"
            _pkg_file="$(makepkg --packagelist | grep "$1" \
                        | grep "$_arch" \
                        | head -1)"
            _pkg_file="$(basename "$_pkg_file")"            
            if [ "x$_pkg_file" != "x" ]
            then
                _log "filename found: '$_pkg_file'"
                return
            else
                _log "filename not found, retrying"
            fi
        done
        _log "searching filename without architecture"
        _warnprint "cannot find architecture for ${_color_blue}$1"
        _pkg_file="$(makepkg --packagelist | grep "$1" | head -1)"
        _pkg_file="$(basename "$_pkg_file")"
        # return if _pkg_file has a value
        if [ "x$_pkg_file" != "x" ] 
        then
            _log "filename found: '$_pkg_file'"
            return
        else
            _log "filename not found"
            _err "failed to retrieve the filename for ${_color_blue}$1"
        fi
    else
        _log "filename not found"
        _err "failed to retrieve the filename for ${_color_blue}$1"
    fi
}
# Get package info
#
function _pkg_info() {
    # '$_pkg_dir  ' from _start_search
    if _real_pkg_dir="$(readlink "$_pkg_dir")"
    then
        if [ "x$_real_pkg_dir" = "x$_old_pkg_dir" ]
        then
            return
        fi  
    else
        if [ "x$_pkg_dir" = "x$_old_pkg_dir" ]
        then
            return
        fi
    fi
    _old_pkg_dir="$_pkg_dir"
    # Make sure pkgver is empty
    unset pkgver 
    # shellcheck disable=SC1091
    source ./PKGBUILD 2> /dev/null
    # Check if PKGBUILD has been patched already
    _log "checking if PKGBUILD has been patched"
    # shellcheck disable=SC2016
    if [[ "$pkgver" != *"_src" ]]
    then
        [ ! -f "PKGBUILD.orig" ] && cp PKGBUILD PKGBUILD.orig
        _log "PKGBUILD has not been patched, patching"
        _wprint "Patching PKGBUILD for ${_color_blue}$1"
        # Example code for this pkgver change
        # Example pkgver=1.0
        #
        # source=('example.com/files/$pkgname-$pkgver')
        # =
        # source=('example.com/files/${pkgname}-1.0')
        sed -i s/'$pkgver'/"$pkgver"/g          PKGBUILD
        # source=('example.com/files/${pkgname}_${pkgver}')
        # =
        # source=('example.com/files/${pkgname}_1.0')
        sed -i s/'${pkgver}'/"$pkgver"/g        PKGBUILD
        # source=('example.com/files/${pkgname}_${pkgver//./_}')
        # =
        # source=('example.com/files/${pkgname}_${origpkgver//./_}')
        sed -i s/'${pkgver'/'${origpkgver'/g    PKGBUILD
        #
        # pkgver=1.0
        # =
        # pkgver=1.0_src \n origpkgver=1.0
        _sprint "changing pkgver to ${_color_blue}${pkgver}_src"
        _pkgbuild_data="$(cat PKGBUILD)"
        _in_func=no
        _in_func_next=no
        _input_char_active=no
        _pkgbuild_patch_fail=no
        _echo=yes
        while read -r line 
        do
            # if the line contains pkgver= then replace and add
            # pkgver=[VERSION]_src
            # origpkgver=[VERSION]
            [[ "$line" = "pkgver="* ]] && echo -e "pkgver=${pkgver}_src\\norigpkgver=$pkgver" && _echo=no
            # 
            # If _in_func_next = yes then set _in_func to yes
            [ "$_in_func_next" = "yes" ] && _in_func=yes
            #
            # If the line contains '{' add \t at the next line
            if [[ "$line" = *"{" ]] && \
                [ "$_input_char_active" = "no" ]
            then 
                _in_func_next=yes 
                _in_func=no
            fi
            #
            # If the line contains '}' do not add \t to the line 
            if [[ "$line" = "}"* ]] && \
                [ "$_input_char_active" = "no" ]
            then 
                _in_func=no
                _echo=yes
            fi
            #
            # If _input_next_line = yes then no \t
            [[ "$_input_next_line" = "yes" ]] && _in_func=no
            #
            # If the line contains the _input_char_name then add \t to the next line
            if [[ "$line" = "$_input_char_name" ]] && \
                [[ "x$_input_char_name" != "x" ]]
            then 
                _in_func_next=yes
                _input_next_line=no
                _input_char_active=no
                unset _input_char_name
            fi
            # 
            # If the line contains '<<' do not add \t to the next line
            if [[ "$line" = *"<<"* ]] && \
                [[ "$line" != *"'<<'"* ]] && \
                [[ "$line" != *"\"<<\""* ]] && \
                [[ "$line" != *"< $"* ]]
            then 
                _input_next_line=yes
                _input_char_active=yes
                _echo=yes
                _input_char_name="$(echo "$line" | cut -d'<' -f3)"
                # Verify that _input_char_name isn't empty
                if [ "x$_input_char_name" = "x" ]
                then
                    # loop from 2 to 200 to be sure
                    for ((i=2; i < 200; i++))
                    do
                        _input_char_name="$(echo "$line" | cut -d'<' -f$i)"
                        if [ "x$_input_char_name" != "x" ] && \
                            [ "$_input_char_name" != "<" ]
                        then
                            break
                        fi
                    done
                    _pkgbuild_patch_fail=yes
                fi
            fi
            #
            # if it's in the function, add \t before the text
            [ "$_in_func" = "yes" ] && echo -e "\\t$line" && _echo=no
            #
            # If _echo = yes then show the original line without additions
            [ "$_echo" = "yes" ] && echo "$line" || _echo=yes
        done < <(echo -e "$_pkgbuild_data\\n") > PKGBUILD
        #
        # Check if patching failed, if it failed revert the changes
        if [ "$_pkgbuild_patch_fail" = "yes" ]
        then
            _warnprint "failed to patch PKGBUILD, reverting.."
            _log "copying PKGBUILD.orig to PKGBUILD"
            cp PKGBUILD.orig PKGBUILD
            return
        fi
        # Example pkgver function
        #
        # pkgver() {
        #   echo 1.1
        # } 
        # =
        # pkgver() {
        #   echo '1.0_src'
        #   return
        #   echo 1.1
        # }
        #
        # Grep the pkgver function
        _line="$(grep "pkgver*.*() {" PKGBUILD -n | cut -d':' -f1 2> /dev/null)"
        # Check if grep found something
        if _line="$(grep "pkgver*.*() {" PKGBUILD -n | cut -d':' -f1)" && \
            [ "x$_line" != "x" ]
        then
            _sprint "changing pkgver function to dummy function"
            _rline=$((_line + 1)) 2> /dev/null
            sed -i "${_rline}s^.*^\\techo \\'${pkgver}_src\\'\\n\\treturn\\n^g" PKGBUILD
        fi
        _sprint "generating SRCINFO"
        makepkg --printsrcinfo > .SRCINFO
        pkgver="${pkgver}_src"
    else
        _log "PKGBUILD has been patched already"
    fi
}
# Ask the user if they want to edit the PKGBUILD
#
function _ask_edit() {
    while true
    do
        echo -e "${_color_green}=>>${_color_reset} ${_color_white}Do you want to edit the PKGBUILD? [Y/n] ${_color_reset}\\c"
        read -r _answer
        # shellcheck disable=SC2154
        case $_answer in
            Y|y|yes|"")
                if [ "$EDITOR" ]
                then
                    $EDITOR PKGBUILD
                elif [ "$VISUAL" ]
                then
                    $VISUAL PKGBUILD
                elif command -v nano > /dev/null 2>&1
                then
                    nano PKGBUILD
                elif command -v vim > /dev/null 2>&1
                then
                    vim PKGBUILD
                elif command -v vi > /dev/null 2>&1
                then
                    vi PKGBUILD
                elif command -v emacs > /dev/null 2>&1
                then
                    emacs PKGBUILD
                else                    
                    _warnprint "nano, vim, vi or emacs could not be found!"
                fi
                return;;
            N|n|no)
                return;;
            *) echo -e "${_color_yel}=>> WARNING:${_color_reset} ${_color_white}Invalid option${_color_reset}";;
        esac
    done
}
# Checks if package has been built already 
#
function _check_cache() {
    _log "checking cache for '$_pkg_file'"
    if [ -f "$_target_cache_dir/$_pkg_file" ]
    then
        _log "'$_pkg_file' found"
        _cached_found=yes
        _log "checking if package has been installed already"
        if [ "$(pacman -Qi "$1" | grep Version | sed -e "s/ //g" -e "s/Version://g" | cut -d':' -f2 | rev | cut -d'-' -f2 | rev)" = "$pkgver" ] && \
            [ "$_ignore_installed" = "no" ]
        then
            _log "package has been installed already"
            _wprint "Package ${_color_blue}$1-$pkgver ${_color_white}has already been installed!"
            return
        fi
        if [ "$_ignore_installed" = "no" ] 
        then
            _log "package has not been installed, insalling '$_pkg_file'"
        fi
        _wprint "Package ${_color_blue}$1 ${_color_white}has been built already, installing cached version!"
        if ! sudo pacman "${_pacman_flags[@]}" -U "$_target_cache_dir/$_pkg_file"
        then
            _err "Failed to install ${_color_blue}$1"
        fi
    else
        _log "'$_pkg_file' not found in cache"
    fi
}
# Displays usage
#
function _usage() {
    if [ "$_quiet" = "no" ]
    then
        echo -e "pacman-src compiles Arch GNU/Linux packages from source using the ABS\\n"
        echo "Usage: pacman-src [OPTION] [PACKAGE]"
        echo -e "\\nOptions:"
        echo "  -u, --update        updates the cache"
        echo "  -b. --build         build-only, no installing"
        echo "  -m, --cache         use the cache to store the built packages"
        echo "  -f, --force         passes --force to pacman and makepkg"
        echo "  -s, --skipchecks    skips any integrity check(s)"
        echo "  -n, --noconfirm     passes --noconfirm to pacman and makepkg"
        echo "  -t, --testing       builds the latest version of the given package(s)"
        echo "  -q, --quiet         silent mode"
        echo "  -Q, --search        searches the given package(s), returns 0 when found"
        echo "  --reset             resets git repos from the cache"
        echo "  --config=[FILE]     uses configuration options from given config file"
        echo "  --ignore-installed  installs built packages, even if it's already installed"
        echo "  --trunk             uses trunk, does not use repos"
        echo "  -l, --nocheck       skips do_check function for given package(s)"
        echo "  -c, --cleanbuild    cleans build before building package"
        echo "  -d, --dirty         does not clean, even when build was successful"
        echo "  -g, --ignore        does not exit after error"
        echo "  -x, --nowarn        disables warning(s)"
        echo "  --verbose           shows debug data"
        echo "  -h, --help          displays this help and exit"
        echo "  -v, --version       displays version and exit"
        echo -e "\\nExamples:"
        echo "  pacman-src base     (re)compiles all packages from base group"
        echo -e "  pacman-src bash -n  compiles and installs bash package without confirmation\\n"
        echo "Report bugs to https://github.com/tim241/pacman-src/issues"
    fi
}
# Displays version
#
function _version() {
    echo -e "pacman-src @VERSION@\\n"
    echo "Copyright (C) 2018 Tim Wanders"
    echo -e "This is free software; see the source for copying conditions.\\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n"
    echo "Written by Tim Wanders."
}
# Main build loop
#
function _build_loop() {
    if [ "$_search_only" = "yes" ] || \
        [ "${#@}" = "0" ]
    then
        return
    fi
    for _package in "$@"
    do
        _start_search "$_package"
        if [ "$_pkg_group" = "no" ]
        then
            _pkg_info      "$_package"
            _pkg_info_file "$_package"
            [ "$_cache" = "yes" ] && _check_cache "$_package"
            _wprint "[$_package_num/$_package_total] Building ${_color_blue}$1"
            [ "$_noconfirm" = "no" ] && _ask_edit
            _start_build "$_package"
            ((_package_num++))
        else
            _pkg_group=no
        fi
    done
}
# Sources given config file
#
function _use_config() {
    _config="$(echo "$1" | cut -d'=' -f2)"
    if [ -f "$_config" ] &&
       [ "x$_config" != "x" ]
    then
        # shellcheck disable=SC1090
        source "$_config"
    else
        _usage
    fi    
}
# Resets repos
#
function _reset() {
    _wprint "Resetting repos"
    for repo in "${_repos[@]}"
    do
        if [ -d "$_target_dir/packages/$repo" ]
        then
            cd "$_target_dir/packages/$repo" || return
            _sprint "resetting ${_color_blue}$repo"
            git reset --hard > /dev/null 2>&1
        fi
    done
}
# Short argument parser
#
function _parse_short() {
    args=$(echo "$@" | sed "s/-//g" | grep -o .)
    for arg in $args
    do
        case $arg in
                b) _build_only=yes;;
                q) _quiet=yes;;
                Q) _search_only=yes;;
                u) _update=yes;;
                s) _makepkg_flags+=(--skipinteg);;
                n) _makepkg_flags+=(--noconfirm); _pacman_flags+=(--noconfirm); _noconfirm=yes;;
                c) _makepkg_flags+=(--cleanbuild); _cleanbuild=yes;;
                t) _repo_testing=yes;;
                d) _clean=no;;
                f) _makepkg_flags+=(-f); _pacman_flags+=(--force);;
                l) _makepkg_flags+=(--nocheck);;
                m) _cache=yes;;
                g) _ignore_error=yes;;
                x) _nowarn=yes;;
                h) _usage; exit;;
                v) _version; exit;;
                *) _usage; exit 1;;
        esac
    done
}
if [ "${#@}" = "0" ]
then
    _usage
    exit
fi
for _argument in "$@"
do
    case $_argument in
        --build)            _build_only=yes;;
        --quiet)            _quiet=yes;;
        --search)           _search_only=yes;;
        --update)           _update=yes;;
        --skipchecks)       _makepkg_flags+=(--skipinteg);;
        --noconfirm)        _makepkg_flags+=(--noconfirm); _pacman_flags+=(--noconfirm); _noconfirm=yes;;
        --cleanbuild)       _makepkg_flags+=(--cleanbuild); _cleanbuild=yes;;
        --nocheck)          _makepkg_flags+=(--nocheck);;
        --trunk)            _trunk=yes;;
        --ignore-installed) _ignore_installed=yes;;
        --testing)          _repo_testing=yes;;
        --dirty)            _clean=no;;
        --reset)            _reset;;
        --force )           _makepkg_flags+=(-f); _pacman_flags+=(--force);;
        --cache)            _cache=yes;;
        --ignore)           _ignore_error=yes;;
        --nowarn)           _nowarn=yes;;
        --config=*)         _use_config "$_argument";;
        --verbose)          _verbose=yes;;
        --help)             _usage; exit;;
        --version)          _version; exit;;
        --*)                _usage; exit 1;;
        -*)                 _parse_short "$_argument" ;;
        *)                  _packages+=("$_argument");;
    esac
done
_checkreq
_init_cache
[ "$_update" = "yes" ] && _update_cache
# Search all packages before building
if [ "${_packages[0]}" ]
then  
    _wprint "Searching packages"
fi
_search_pkg_only=yes
for _package in "${_packages[@]}"
do
    _nowarn=yes
    _sprint "searching ${_color_blue}$_package"
    _start_search "$_package"
    _nowarn=no
done
# Remove duplicates
if [ "${_packages[1]}" ]
then  
    _wprint "Searching for duplicate packages"
fi
for _package in "${_packages[@]}"
do
    # shellcheck disable=SC2145
    _log "checking if '$_package' is in '${_dpackages[@]}'"
    for _dpackage in "${_dpackages[@]}"
    do
        if [ "$_dpackage" = "$_package" ]
        then
            _log "'$_package' found"
            _sprint "duplicate found: ${_color_blue}$_package"
            _duplicate=yes
        fi
    done
    if [ "$_duplicate" != "yes" ]
    then
        _log "adding '$_package' to _stripped_packages and _dpackages"
        _stripped_packages+=("$_package")
        _dpackages+=("$_package")
        ((_package_total++))
    fi
done
_search_pkg_only=no
# Start searching and building
_log "running main build loop over _stripped_packages (packages)"
_build_loop "${_stripped_packages[@]}"
_log "running main build loop over _packages_group (groups)"
_build_loop "${_packages_group[@]}"

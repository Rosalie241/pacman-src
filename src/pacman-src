#!/usr/bin/env bash
#
# pacman-src - https://github.com/tim241/pacman-src
#
# Copyright (C) 2018 Tim Wanders <timwanders241@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
if [ ! "$XDG_CACHE_HOME" ]
then
    XDG_CACHE_HOME="$HOME/.cache"
fi
# Declare colors
#
_color_white='\033[1;37m'
_color_green='\033[1;32m'
_color_red='\033[1;31m'
_color_yel='\033[0;33m'
_color_blue='\033[0;34m'
_color_reset='\033[0m' 
# Declare other stuff
#
_target_dir="$XDG_CACHE_HOME/pacman-src"
_target_cache_dir="$_target_dir/cache/"
_update=no
_build_only=no
_repo_testing=no
_makepkg_flags=(-s)
_git_flags=("--depth=1")
_repos=(core community)
_stable_repos=(core community extra multilib)
_testing_repos=(testing community-testing multilib-testing)
_repo_archs=(any x86_64)
_newline=yes
_quiet=no
_search_only=no
_small_update=no
_nowarn=no
_clean=yes
_cache=no
_cached_found=no
_ignore_error=no
_pkg_file=none
_pkg_arch=none
# Print text
#
function _print() {
    if [ "$_quiet" = "no" ]
    then
        if [ "$_newline" = "yes" ]
        then
            echo -e "\\n$*\\n"
        else
            echo -e "$*"
        fi
    fi
    return
}
# Print white text
function _wprint() {
    _print "${_color_green}=>>${_color_reset} ${_color_white}$* ${_color_reset}"
}
# Print red error text
function _errprint() {
    _print "${_color_red}=>> ERROR:${_color_reset} ${_color_white}$*${_color_reset}"
}
# Print yellow warning text
function _warnprint() {
    if [ "$_nowarn" = "no" ]
    then
        _print "${_color_yel}=>> WARNING:${_color_reset} ${_color_white}$*${_color_reset}"
    fi
}
# Print sub info
function _sprint() {
    _newline=no
    _print "  ${_color_blue}->${_color_white} $*${_color_reset}"
    _newline=yes
}
# Error out
#
function _err() {
    _errprint "$@"
    if [ "$_ignore_error" = "no" ]
    then
        exit 1
    fi
}
# clone the package repo to init the cache
#
function _init_cache() {
    if [ ! -d "$_target_dir" ] || \
        [ ! -d "$_target_dir/packages" ] || \
        [ ! -d "$_target_dir/packages/core" ] || \
        [ ! -d "$_target_dir/packages/community" ]
    then
        mkdir -p "$_target_dir"
        _wprint "Cloning packages repos"
        git clone git://git.archlinux.org/svntogit/packages.git  "${_git_flags[@]}" "$_target_dir/packages/core"
        git clone git://git.archlinux.org/svntogit/community.git "${_git_flags[@]}" "$_target_dir/packages/community"
        _update_symlinks 
    fi
}
# Update the cache
#
function _update_cache() {
    _wprint "Updating repos"
    for repo in "${_repos[@]}"
    do
        cd "$_target_dir/packages/$repo" || exit 1
        _sprint "updating ${_color_blue}$repo ${_color_white}repo"
        git fetch --all "${_git_flags[@]}" > /dev/null
        git reset --hard                 > /dev/null
    done
}
# Update symlinks
#
function _update_symlinks() {
    _wprint "Updating symlinks"
    for _repo in "${_repos[@]}"
    do
        _target_repo_dir="$_target_dir/packages/$_repo"
        find "$_target_repo_dir" -name "PKGBUILD" 2> /dev/null | while read -r _package
        do
            # Disable warnings
            # shellcheck disable=SC1090
            source "$_package" 2>/dev/null
            # shellcheck disable=SC2154            
            for _item in "${pkgname[@]}"
            do 
                if [[ $_package != *repos* ]]
                then
                    _item="$(echo    "$_item"    | rev | cut -d'/' -f2 | rev)"
                    _package="$(echo "$_package" | rev | cut -d'/' -f3 | rev)"
                    _source="$_target_repo_dir/$_package"
                    _target="$_target_repo_dir/$_item"
                    if [ ! -d "$_target" ] && \
                        [ ! -f "$_source" ] && \
                        [ "$_source" != "$_target" ]
                    then
                        _newline=no
                        _sprint "${_color_white}Linking ${_color_yel}$_source ${_color_white}to ${_color_blue}$_target"
                        _newline=yes
                        ln -s "$_source" "$_target"
                    fi
                fi
            done
        done
    done
}
function _build_cd () {
    # note: '$repo' is from _start_search
    _found_dir=false
    for _arch in "${_repo_archs[@]}"
    do
        for _repo in "$@"
        do
            _target_build_dir="$_target_dir/packages/$repo/$_pkgname/repos/$_repo-$_arch"
            if [ -d "$_target_build_dir" ]
            then
                _found_dir=true
                _pkg_arch="$_arch"
                cd "$_target_build_dir" || exit 1
            fi
        done
    done
    if [ "$_found_dir" = "false" ]
    then
        _warnprint "${_color_blue}$_pkgname ${_color_white}not found in the ${_color_blue}$_repo_version ${_color_white}repos, building latest.."
        cd "$_target_dir/packages/$repo/$_pkgname/trunk" || exit 1
    fi
}
# Search the package
#
function _start_search() {
    for repo in "${_repos[@]}"
    do
        _pkgname=$1
        if [ -d "$_target_dir/packages/$repo/$_pkgname" ]
        then
            _pkg_not_found=no
            if [ "$_repo_testing" = "yes" ]
            then
                _repo_version="testing"
                _build_cd "${_testing_repos[@]}"
            else
                _repo_version="stable"
                _build_cd "${_stable_repos[@]}"
            fi
            return
        else
            _pkg_not_found=yes
        fi
    done
    if [ "$_pkg_not_found" = "yes" ]
    then
        _err "${_color_blue}$1${_color_white} not found!"
    fi
}
# Start the build using makepkg
#
function _start_build() {
    if [ "$_cached_found" = "yes" ]
    then
        _cached_found=no
        return
    fi
    _wprint "Building ${_color_blue}$1"
    if [ "$_build_only" = "yes" ] || \
        [ "$_cache" = "yes" ]
    then
        if [ ! -d "$_target_cache_dir" ]
        then
            mkdir -p "$_target_cache_dir"
        fi
        export PKGDEST="$_target_cache_dir"
    fi
    if makepkg "${_makepkg_flags[@]}"
    then        
        if [ "$_build_only" = "no" ]
        then
            _wprint "Installing ${_color_blue}$1"
            if ! sudo pacman "${_pacman_flags[@]}" -U "$_pkg_file"
            then
                _err "Installing ${_color_blue}$1 ${_color_white}failed!"
            fi
        fi
        if [ "$_clean" = "yes" ]
        then
            _wprint "Cleaning ${_color_blue}$1"
            git clean -fdxq
        fi
        return
    else
        _err "Building ${_color_blue}$1 ${_color_white}failed!"
    fi
}
# Checks requirements
#
function _checkreq() {
    # Make sure we're not running as root!
    if [ "$UID" = "0" ]
    then
        _errprint "running this program as root is NOT allowed!"
        exit 1
    fi
    _missing_req=no
    for _cmd in git pacman bash makepkg ln sudo
    do
        if ! command -v $_cmd > /dev/null 2>/dev/null
        then
            _errprint "Missing requirement: ${_color_blue}$_cmd"
            _missing_req=yes
        fi
    done
    if [ "$_missing_req" = "yes" ]
    then
        exit 1
    fi
    if [ -f "/etc/os-release" ]
    then
        ID=NULL
        export "$(grep ID /etc/os-release | head -1)" 2>/dev/null
        if [ "$ID" != "arch" ]
        then
            _warnprint "Unsupported platform detected, continue at your own risk"
        fi
        unset ID
    fi
    if [ ! -f "/etc/makepkg.conf" ]
    then
        _err "makepkg.conf not found!"
    else
        # shellcheck disable=SC1091
        source "/etc/makepkg.conf"
        if [ ! "$PKGEXT" ]
        then
            _err "PKGEXT is empty!"
        fi
    fi
}
# Get package info
#
function _pkg_info() {
    # shellcheck disable=SC1091
    source ./PKGBUILD 2> /dev/null
    # '$_pkg_arch' from _build_cd
    if _pkg_file="$(makepkg --packagelist | grep "$1" | grep "$_pkg_arch" | head -1)$PKGEXT"
    then
        for _arch in "${_repo_archs[@]}"
        do
            _pkg_file="$(makepkg --packagelist | grep "$1" | grep "$_arch" | head -1)$PKGEXT"
            if [ "$_pkg_file" != "$PKGEXT" ]
            then
                return
            fi
        done
        # Extra sanity check
        if [ "$_pkg_file" = "$PKGEXT" ]
        then
            _warnprint "cannot find architecture for ${_color_blue}$1"
            _pkg_file="$(makepkg --packagelist | grep "$1" | head -1)$PKGEXT"
            if [ "$_pkg_file" = "$PKGEXT" ]
            then
                _err "failed to retrieve the filename for ${_color_blue}$1"
            else
                return
            fi
        fi

    else
        _err "failed to retrieve the filename for ${_color_blue}$1"
    fi
}
# Checks if package has been built already 
#
function _check_cache() {
    if [ -f "$_target_cache_dir/$_pkg_file" ]
    then
        _cached_found=yes
        _wprint "Package ${_color_blue}$1 ${_color_white}has been built already, installing cached version!"
        if ! sudo pacman "${_pacman_flags[@]}" -U "$_target_cache_dir/$_pkg_file"
        then
            _err "Failed to install ${_color_blue}$1"
        fi
    fi
}
# Displays usage
#
function _usage() {
    echo "$0 [package]            | Builds and installs the package   "
    echo "$0 [--update    |  -u]  | Updates the cache                 "
    echo "$0 [--build     |  -b]  | Build-only, no installing         "
    echo "$0 [--cache     |  -m]  | Use cache"
    echo "$0 [--force     |  -f]  | Force overwrite built package     "
    echo "$0 [--skipchecks|  -s]  | Skips any integrity check         "
    echo "$0 [--noconfirm |  -n]  | No confirmation                   "
    echo "$0 [--testing   |  -t]  | Builds the latest version         "
    echo "$0 [--quiet     |  -q]  | silent mode                       "
    echo "$0 [--search    |  -Q]  | Searches the given package, returns 0 if found"
    echo "$0 [--supdate   |  -k]  | Updates the cache without linking"
    echo "$0 [--nocheck   |  -l]  | skips do_check function from PKGBUILD"
    echo "$0 [--cleanbuild|  -c]  | cleans build before building the package"
    echo "$0 [--dirty     |  -d]  | Does not clean even when build was successful"
    echo "$0 [--ignore    |  -g]  | Does not exit after error"
}
function _parse_short() {
    args=$(echo "$@" | sed "s/-//g" | grep -o .)
    for arg in $args
    do
        case $arg in
                b) _build_only=yes;;
                q) _quiet=yes;;
                Q) _search_only=yes;;
                u) _update=yes;;
                k) _small_update=yes; _update=yes;;
                s) _makepkg_flags+=(--skipinteg);;
                n) _makepkg_flags+=(--noconfirm); _pacman_flags+=(--noconfirm);;
                c) _makepkg_flags+=(--cleanbuild);;
                t) _repo_testing=yes;;
                d) _clean=no;;
                f) _makepkg_flags+=(-f); _pacman_flags+=(--force);;
                l) _makepkg_flags+=(--nocheck);;
                m) _cache=yes;;
                g) _ignore_error=yes;;
                h|*) _usage; exit;;
        esac
    done
}
_checkreq
_init_cache
if [ "${#@}" = "0" ]
then
    _usage
    exit
fi
for _argument in "$@"
do
    case $_argument in
        --build)        _build_only=yes;;
        --quiet)        _quiet=yes;;
        --search)       _search_only=yes;;
        --update)       _update=yes;;
        --supdate)      _small_update=yes; _update=yes;;
        --skipchecks)   _makepkg_flags+=(--skipinteg);;
        --noconfirm)    _makepkg_flags+=(--noconfirm); _pacman_flags+=(--noconfirm);;
        --cleanbuild)   _makepkg_flags+=(--cleanbuild);;
        --nocheck)      _makepkg_flags+=(--nocheck);;
        --testing)      _repo_testing=yes;;
        --dirty)        _clean=no;;
        --force )       _makepkg_flags+=(-f); _pacman_flags+=(--force);;
        --cache)        _cache=yes;;
        --ignore)       _ignore_error=yes;;
        --help|--*)     _usage; exit;;
        -*)             _parse_short "$_argument" ;;
        *)              _packages+="$_argument ";;
    esac
done
if [ "$_update" = "yes" ]
then
    _update_cache
    if [ "$_small_update" = "no" ]
    then
        _update_symlinks
    fi
fi
# Search all packages before building
if [ "$_packages" ]
then  
    _wprint "Searching packages"
fi
for _package in $_packages
do
    _nowarn=yes
    _sprint "searching ${_color_blue}$_package"
    _start_search "$_package"
    _nowarn=no
done
if [ "$_search_only" = "no" ]
then
    for _package in $_packages
    do
        _start_search "$_package"
        _pkg_info "$_package"
        if [ "$_cache" = "yes" ]
        then
            _check_cache "$_package"
        fi
        _start_build "$_package"
    done
fi

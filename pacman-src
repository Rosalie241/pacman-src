#!/usr/bin/env bash
#
# pacman-src - https://github.com/tim241/pacman-src
#
# Copyright (C) 2018 Tim Wanders <timwanders241@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
if [ ! "$XDG_CACHE_HOME" ]
then
    XDG_CACHE_HOME="$HOME/.cache"
fi
# Declare colors
#
_color_white='\033[1;37m'
_color_green='\033[1;32m'
_color_red='\033[1;31m'
_color_yel='\033[0;33m'
_color_blue='\033[0;34m'
_color_reset='\033[0m' 
# Declare other stuff
#
_target_dir="$XDG_CACHE_HOME/pacman-src"
_update=no
_build_only=no
_repo_testing=no
_makepkg_flags="-s"
_git_flags="--depth=1"
_install_makepkg_flags="-i"
_repos="core community"
_stable_repos="core community extra multilib"
_testing_repos="testing community-testing multilib-testing"
_repo_archs="any x86_64"
_newline=yes
_quiet=no
_search_only=no
_small_update=no
_nowarn=no
_clean=yes
_cache=no
_cached_found=no
# Print text
#
function _print() {
    if [ "$_quiet" = "no" ]
    then
        if [ "$_newline" = "yes" ]
        then
            echo -e "\\n$*\\n"
        else
            echo -e "$*"
        fi
    fi
    return
}
# Print white text
function _wprint() {
    _print "${_color_green}=>>${_color_reset} ${_color_white}$* ${_color_reset}"
}
# Print red error text
function _errprint() {
    _print "${_color_red}=>> ERROR:${_color_reset} ${_color_white}$*${_color_reset}"
}
# Print yellow warning text
function _warnprint() {
    if [ "$_nowarn" = "no" ]
    then
        _print "${_color_yel}=>> WARNING:${_color_reset} ${_color_white}$*${_color_reset}"
    fi
}
# Print sub info
function _sprint() {
    _newline=no
    _print "  ${_color_blue}->${_color_white} $*${_color_reset}"
    _newline=yes
}
# clone the package repo to init the cache
#
function _init_cache() {
    if [ ! -d "$_target_dir" ] || \
        [ ! -d "$_target_dir/packages" ] || \
        [ ! -d "$_target_dir/packages/core" ] || \
        [ ! -d "$_target_dir/packages/community" ]
    then
        mkdir -p "$_target_dir"
        _wprint "Cloning packages repos"
        git clone git://git.archlinux.org/svntogit/packages.git  $_git_flags "$_target_dir/packages/core"
        git clone git://git.archlinux.org/svntogit/community.git $_git_flags "$_target_dir/packages/community"
    fi
}
# Update the cache
#
function _update_cache() {
    if [ "$_update" = "yes" ]
    then
        _wprint "Updating repos"
        for repo in $_repos
        do
            cd "$_target_dir/packages/$repo" || exit 1
            _sprint "updating ${_color_blue}$repo ${_color_white}repo"
            git fetch --all $_git_flags     > /dev/null
            git reset --hard                > /dev/null
        done
    fi
}
# Update symlinks
#
function _update_symlinks() {
    if [ "$_update" = "yes" ]
    then
        _wprint "Updating symlinks"
        for _repo in $_repos
        do
            _target_repo_dir="$_target_dir/packages/$_repo"
            find "$_target_repo_dir" -name "PKGBUILD" 2> /dev/null | while read -r _package
            do
                source "$_package" 2>/dev/null 
                for _item in ${pkgname[@]}
                do 
                    if [[ $_package != *repos* ]]
                    then
                        _item="$(echo    "$_item"    | rev | cut -d'/' -f2 | rev)"
                        _package="$(echo "$_package" | rev | cut -d'/' -f3 | rev)"
                        _source="$_target_repo_dir/$_package"
                        _target="$_target_repo_dir/$_item"
                        if [ ! -d "$_target" ] && \
                            [ ! -f "$_source" ] && \
                            [ "$_source" != "$_target" ]
                        then
                            _newline=no
                            _sprint "${_color_white}Linking ${_color_yel}$_source ${_color_white}to ${_color_blue}$_target"
                            _newline=yes
                            ln -s "$_source" "$_target"
                        fi
                    fi
                done
            done
        done
    fi
}
function _build_cd () {
    # note: '$repo' is from _start_search
    _found_dir=false
    for arch in $_repo_archs
    do
        for _repo in $@
        do
            _target_build_dir="$_target_dir/packages/$repo/$_pkgname/repos/$_repo-$arch"
            if [ -d "$_target_build_dir" ]
            then
                _found_dir=true
                cd "$_target_build_dir" || exit 1
            fi
        done
    done
    if [ "$_found_dir" = "false" ]
    then
        _warnprint "${_color_blue}$_pkgname ${_color_white}not found in the ${_color_blue}$_repo_version ${_color_white}repos, building latest.."
        cd "$_target_dir/packages/$repo/$_pkgname/trunk" || exit 1
    fi
}
# Search the package
#
function _start_search() {
    for repo in $_repos
    do
        _pkgname=$1
        if [ -d "$_target_dir/packages/$repo/$_pkgname" ]
        then
            _pkg_not_found=no
            if [ "$_repo_testing" = "yes" ]
            then
                _repo_version="testing"
                _build_cd "$_testing_repos"
            else
                _repo_version="stable"
                _build_cd "$_stable_repos"
            fi
            return
        else
            _pkg_not_found=yes
        fi
    done
    if [ "$_pkg_not_found" = "yes" ]
    then
        _errprint "${_color_blue}$1${_color_white} not found!"
        exit 1
    fi
}
# Start the build using makepkg
#
function _start_build() {
    if [ "$_cached_found" = "yes" ]
    then
        _cached_found=no
        return
    fi
     _target_build_dir="$_target_dir/build/"
    if [ "$_build_only" = "yes" ] || \
        [ "$_cache" = "yes" ]
    then
        if [ ! -d "$_target_build_dir" ]
        then
            mkdir -p "$_target_build_dir"
        fi
        _makepkg_flags+=" PKGDEST=""$_target_build_dir"""
    fi
    if makepkg $_makepkg_flags
    then
        _target_build_dir="$_target_dir/build"
        if [ "$_build_only" = "no" ]
        then
            _wprint "Installing ${_color_blue}$1"
            if ! sudo pacman $_pacman_flags -U $1-*.pkg*
            then
                _errprint "Installing ${_color_blue}$1 ${_color_white}failed!"
                exit 1
            fi
        fi
        if [ "$_clean" = "yes" ]
        then
            _wprint "Cleaning ${_color_blue}$1"
            git clean -fdxq
        fi
        return
    else
        _errprint "Building ${_color_blue}$1 ${_color_white}failed!"
        exit 1
    fi
}
# Checks requirements
#
function _checkreq() {
    _missing_req=no
    for _cmd in git pacman bash makepkg ln
    do
        if ! command -v $_cmd > /dev/null 2>/dev/null
        then
            _errprint "Missing requirement: ${_color_blue}$_cmd"
            _missing_req=yes
        fi
    done
    if [ "$_missing_req" = "yes" ]
    then
        exit 1
    fi
    
    if [ -f "/etc/os-release" ]
    then
        ID=NULL
        export "$(grep ID /etc/os-release | head -1)" 2>/dev/null
        if [ "$ID" != "arch" ]
        then
            _warnprint "Unsupported platform detected, continue at your own risk"
        fi
        unset ID
    fi
}
# Checks if package has been built already 
#
function _check_cache() {
    source PKGBUILD 2> /dev/null
    if [ -f "$_target_dir/build/"$1-$pkgver* ]
    then
        _cached_found=yes
        _wprint "Package ${_color_blue}$1 ${_color_white}has been built already, installing cached version!"
        if ! sudo pacman $_pacman_flags -U "$_target_dir/build/"$1-$pkgver*
        then
            _errprint "Failed to install ${_color_blue}$1"
            exit 1
        fi
    fi
}
# Displays usage
#
function _usage() {
    echo "$0 [package]            | Builds and installs the package   "
    echo "$0 [--update    |  -u]  | Updates the cache                 "
    echo "$0 [--build     |  -b]  | Build-only, no installing         "
    echo "$0 [--cache     |  -m]  | Use cache"
    echo "$0 [--force     |  -f]  | Force overwrite built package     "
    echo "$0 [--skipchecks|  -s]  | Skips any integrity check         "
    echo "$0 [--noconfirm |  -n]  | No confirmation                   "
    echo "$0 [--testing   |  -t]  | Builds the latest version         "
    echo "$0 [--quiet     |  -q]  | silent mode                       "
    echo "$0 [--search    |  -Q]  | Searches the given package, returns 0 if found"
    echo "$0 [--supdate   |  -k]  | Updates the cache without linking"
    echo "$0 [--nocheck   |  -l]  | skips do_check function from PKGBUILD"
    echo "$0 [--cleanbuild|  -c]  | cleans build before building the package"
    echo "$0 [--dirty     |  -d]  | Does not clean even when build was successful"
}
function _parse_short() {
    args=$(echo "$@" | sed "s/-//g" | grep -o .)
    for arg in $args
    do
        case $arg in
                b) _build_only=yes;;
                q) _quiet=yes;;
                Q) _search_only=yes;;
                u) _update=yes;;
                k) _small_update=yes; _update=yes;;
                s) _makepkg_flags+=" --skipinteg";;
                n) _makepkg_flags+=" --noconfirm"; _pacman_flags+=" --noconfirm";;
                c) _makepkg_flags+=" --cleanbuild";;
                t) _repo_testing=yes;;
                d) _clean=no;;
                f) _makepkg_flags+=" -f"; _pacman_flags+=" --force";;
                l) _makepkg_flags+=" --nocheck";;
                m) _cache=yes;;
                h|*) _usage; exit;;
        esac
    done
}
_checkreq
_init_cache
if [ "${#@}" = "0" ]
then
    _usage
    exit
fi
for item in $@
do
    case $item in
        --build)        _build_only=yes;;
        --quiet)        _quiet=yes;;
        --search)       _search_only=yes;;
        --update)       _update=yes;;
        --supdate)      _small_update=yes; _update=yes;;
        --skipchecks)   _makepkg_flags+=" --skipinteg";;
        --noconfirm)    _makepkg_flags+=" --noconfiirm"; _pacman_flags+=" --noconfirm";;
        --cleanbuild)   _makepkg_flags+=" --cleanbuild";;
        --nocheck)      _makepkg_flags+=" --nocheck";;
        --testing)      _repo_testing=yes;;
        --dirty)        _clean=no;;
        --force )       _makepkg_flags+=" -f"; _pacman_flags+=" --force";;
        --cache)        _cache=yes;;
        --help|--*)     _usage; exit;;
        -*)             _parse_short "$item" ;;
        *)              _packages+="$item ";;
    esac
done
_update_cache
if [ "$_small_update" = "no" ]
then
    _update_symlinks
fi
# Search all packages before building
if [ "$_packages" ]
then  
    _wprint "Searching packages"
fi
for _package in $_packages
do
    _nowarn=yes
    _sprint "searching ${_color_blue}$_package"
    _start_search "$_package"
    _nowarn=no
done
if [ "$_search_only" = "no" ]
then
    for _package in $_packages
    do
        _start_search "$_package"
        if [ "$_cache" = "yes" ]
        then
            _check_cache "$_package"
        fi
        _start_build "$_package"
    done
fi

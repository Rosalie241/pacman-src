#!/usr/bin/env bash
if [ ! "$XDG_CACHE_HOME" ]; then
	XDG_CACHE_HOME="$HOME/.cache"
fi
# Declare colors
#
_color_white='\033[1;37m'
_color_green='\033[1;32m'
_color_red='\033[1;31m'
_color_yel='\033[0;33m'
_color_blue='\033[0;34m'
_color_reset='\033[0m' 
# Declare other stuff
#
_target_dir="$XDG_CACHE_HOME/pacman-src"
_update=no
_build_only=no
_repo_testing=no
_makepkg_flags="-sc"
_git_flags="--depth=1"
_repos="core community"
_stable_repos="core community extra multilib"
_testing_repos="testing community-testing multilib-testing"
_repo_archs="any x86_64"
_newline=yes
# Print text
#
function _print() {
	if [ "$_newline" = "yes" ]
	then
		echo -e "\\n$@\\n"
	else
		echo -e "$@"
	fi
}
# Print white text
function _wprint() {
	_print "${_color_green}=>>${_color_reset} ${_color_white}$@ ${_color_reset}"
}
# Print red error text
function _errprint() {
	_print "${_color_red}=>> ERROR:${_color_reset} ${_color_white}$@${_color_reset}"
}
# Print yellow warning text
function _warnprint() {
	_print "${_color_yel}=>> WARNING:${_color_reset} ${_color_white}$@${_color_reset}"
}
# Print sub info
function _sprint() {
	_newline=no
	_print "  ${_color_blue}->${_color_white} $@${_color_reset}"
	_newline=yes
}
# clone the package repo to init the cache
#
function _init_cache() {
	if [ ! -d "$_target_dir" ] || \
		[ ! -d "$_target_dir/packages" ] || \
		[ ! -d "$_target_dir/packages/core" ] || \
		[ ! -d "$_target_dir/packages/community" ]
	then
		mkdir -p "$_target_dir"
		_wprint "Cloning packages repos"
		git clone git://git.archlinux.org/svntogit/packages.git  $_git_flags "$_target_dir/packages/core"
		git clone git://git.archlinux.org/svntogit/community.git $_git_flags "$_target_dir/packages/community"
	fi
}
# Update the cache
#
function _update_cache() {
	if [ "$_update" = "yes" ]
	then
		_wprint "Updating repos"
		for repo in $_repos
		do
			cd "$_target_dir/packages/$repo" || exit 1
			_sprint "updating ${_color_blue}$repo ${_color_white}repo"
			git fetch --all $_git_flags 	> /dev/null
			git reset --hard				> /dev/null
		done
	fi
}
# Update symlinks
#
function _update_symlinks() {
	if [ "$_update" = "yes" ]
	then
		_wprint "Updating symlinks"
		for _repo in $_repos
		do
			_target_repo_dir="$_target_dir/packages/$_repo"
			find "$_target_repo_dir" -name "PKGBUILD" 2> /dev/null | while read -r _package
			do
				source "$_package" 2>/dev/null 
				for _item in ${pkgname[@]}
				do 
					if [[ $_package != *repos* ]]
					then
						_item="$(echo    "$_item" 	 | rev | cut -d'/' -f2 | rev)"
						_package="$(echo "$_package" | rev | cut -d'/' -f3 | rev)"
						_source="$_target_repo_dir/$_package"
						_target="$_target_repo_dir/$_item"
						if [ ! -d "$_target" ] && \
							[ ! -f "$_source" ] 
	       				then
							_newline=no
							_sprint "${_color_white}Linking ${_color_yel}$_source ${_color_white}to ${_color_blue}$_target"
							_newline=yes
							ln -s "$_source" "$_target"
						fi
					fi
       			done
			done
		done
	fi
}
function _build_cd () {
	_found_dir=false
	for arch in $_repo_archs
	do
		for _repo in $@
			do
			_target_build_dir="$_target_dir/packages/$_repo/$_pkgname/repos/$repo-$arch"
			if [ -d "$_target_build_dir" ]
			then
				_found_dir=true
				cd "$_target_build_dir" || exit 1
			fi
		done
	done
	if [ "$_found_dir" = "false" ]
	then
		_warnprint "${_color_blue}$_pkgname ${_color_white}not found in the ${_color_blue}$_repo_version ${_color_white}repos, building latest.."
		cd "$_target_dir/packages/$repo/$_pkgname/trunk" || exit 1
	fi
}
# Search the package
#
function _start_search() {
	for repo in $_repos
	do
		_pkgname=$1
		if [ -d "$_target_dir/packages/$repo/$_pkgname" ]
		then
			_pkg_not_found=no
			_wprint "Package ${_color_blue}$1${_color_white} found!"
			if [ "$_repo_testing" = "yes" ]
			then
				_repo_version="testing"
				_build_cd "$_testing_repos"
			else
				_repo_version="stable"
				_build_cd "$_stable_repos"
			fi
			return
		else
			_pkg_not_found=yes
		fi
	done
	if [ "$_pkg_not_found" = "yes" ]
	then
		_errprint "${_color_blue}$1${_color_white} not found!"
		exit 1
	fi
}
# Start the build using makepkg
#
function _start_build() {
	if makepkg $_makepkg_flags
	then
		_target_build_dir="$_target_dir/build"
		if [ "$_build_only" = "yes" ]
		then
			if [ ! -d "$_target_build_dir" ]
			then
				mkdir -p "$_target_build_dir"
			fi
			cp ./*.pkg.* "$_target_build_dir"
		else
			_wprint "Installing ${_color_blue}$1"
			if ! makepkg -i
			then
				_errprint "Installing ${_color_blue}$1 ${_color_white}failed!"
				exit 1
			fi
		fi
		return
	else
		_errprint "Building ${_color_blue}$1 ${_color_white}failed!"
		exit 1
	fi
}
# Displays usage
#
function _usage () {
	echo "$0 [package]			| Builds and installs the package	"
	echo "$0 [--update|-u]		| Updates the cache		 			"
	echo "$0 [--build|-b]		| Build-only, no installing	 		"
	echo "$0 [--force|-f]		| Force overwrite built package		"
	echo "$0 [--skipchecks|-s]		| Skips any integrity check		"
	echo "$0 [--noconfirm|-n]		| No confirmation				"
	echo "$0 [--testing|-t]		| Builds the latest version			"
}
_init_cache
for item in $@	
do
	case $item in
		--build 		|-b) _build_only=yes;;
		--update		|-u) _update=yes;;
		--skipchecks	|-s) _makepkg_flags+=" --skipinteg";;
		--noconfirm		|-n) _makepkg_flags+=" --noconfirm";;
		--testing		|-t) _repo_testing="yes";;
		--force			|-f) _makepkg_flags+=" -f";;
		--help   |-h|--*|-*) _usage; exit;;
		*) _packages+="$item "
	esac
done
_update_cache
_update_symlinks
for _package in $_packages
do
	_wprint "Searching ${_color_blue}$_package"
	_start_search "$_package"
	_start_build  "$_package"
done
